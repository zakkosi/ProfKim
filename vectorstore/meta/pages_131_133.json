{
  "doc_id": "pages_131_133",
  "text": "3.1 Point operators\n109\n(a)\n(b)\n(c)\nFigure 3.8 Locally adaptive histogram equalization: (a) original image; (b) block histogram\nequalization; (c) full locally adaptive equalization.\nFigure 3.7d shows the result of applying f(I) = c(I) to the original image. As we\ncan see, the resulting histogram is ﬂat; so is the resulting image (it is “ﬂat” in the sense\nof a lack of contrast and being muddy looking). One way to compensate for this is to only\npartially compensate for the histogram unevenness, e.g., by using a mapping function f(I) =\nαc(I) + (1 −α)I, which is a linear blend between the cumulative distribution function and\nthe identity transform (a straight line). As you can see in Figure 3.7e, the resulting image\nmaintains more of its original grayscale distribution while having a more appealing balance.\nAnother potential problem with histogram equalization (or, in general, image brightening)\nis that noise in dark regions can be ampliﬁed and become more visible. Exercise 3.6 suggests\nsome possible ways to mitigate this, as well as alternative techniques to maintain contrast and\n“punch” in the original images (Larson, Rushmeier, and Piatko 1997; Stark 2000).\nLocally adaptive histogram equalization\nWhile global histogram equalization can be useful, for some images it might be preferable\nto apply different kinds of equalization in different regions. Consider for example the image\nin Figure 3.8a, which has a wide range of luminance values. Instead of computing a single\ncurve, what if we were to subdivide the image into M ×M pixel blocks and perform separate\nhistogram equalization in each sub-block? As you can see in Figure 3.8b, the resulting image\nexhibits a lot of blocking artifacts, i.e., intensity discontinuities at block boundaries.\nOne way to eliminate blocking artifacts is to use a moving window, i.e., to recompute the\nhistogram for every M × M block centered at each pixel. This process can be quite slow\n(M 2 operations per pixel), although with clever programming only the histogram entries\ncorresponding to the pixels entering and leaving the block (in a raster scan across the image)\nneed to be updated (M operations per pixel). Note that this operation is an example of the\nnon-linear neighborhood operations we study in more detail in Section 3.3.1.\nA more efﬁcient approach is to compute non-overlapped block-based equalization func-\ntions as before, but to then smoothly interpolate the transfer functions as we move between\n110\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nt\ns\nt\ns\n(a)\n(b)\nFigure 3.9 Local histogram interpolation using relative (s, t) coordinates: (a) block-based\nhistograms, with block centers shown as circles; (b) corner-based “spline” histograms. Pixels\nare located on grid intersections. The black square pixel’s transfer function is interpolated\nfrom the four adjacent lookup tables (gray arrows) using the computed (s, t) values. Block\nboundaries are shown as dashed lines.\nblocks. This technique is known as adaptive histogram equalization (AHE) and its contrast-\nlimited (gain-limited) version is known as CLAHE (Pizer, Amburn, Austin et al. 1987).3 The\nweighting function for a given pixel (i, j) can be computed as a function of its horizontal\nand vertical position (s, t) within a block, as shown in Figure 3.9a. To blend the four lookup\nfunctions {f00, . . . , f11}, a bilinear blending function,\nfs,t(I) = (1 −s)(1 −t)f00(I) + s(1 −t)f10(I) + (1 −s)tf01(I) + stf11(I)\n(3.10)\ncan be used. (See Section 3.5.2 for higher-order generalizations of such spline functions.)\nNote that instead of blending the four lookup tables for each output pixel (which would be\nquite slow), we can instead blend the results of mapping a given pixel through the four neigh-\nboring lookups.\nA variant on this algorithm is to place the lookup tables at the corners of each M × M\nblock (see Figure 3.9b and Exercise 3.7). In addition to blending four lookups to compute the\nﬁnal value, we can also distribute each input pixel into four adjacent lookup tables during the\nhistogram accumulation phase (notice that the gray arrows in Figure 3.9b point both ways),\ni.e.,\nhk,l(I(i, j)) += w(i, j, k, l),\n(3.11)\nwhere w(i, j, k, l) is the bilinear weighting function between pixel (i, j) and lookup table\n(k, l). This is an example of soft histogramming, which is used in a variety of other applica-\n3This algorithm is implemented in the MATLAB adapthist function.\n3.2 Linear ﬁltering\n111\ntions, including the construction of SIFT feature descriptors (Section 4.1.3) and vocabulary\ntrees (Section 14.3.2).\n3.1.5 Application: Tonal adjustment\nOne of the most widely used applications of point-wise image processing operators is the\nmanipulation of contrast or tone in photographs, to make them look either more attractive or\nmore interpretable. You can get a good sense of the range of operations possible by opening\nup any photo manipulation tool and trying out a variety of contrast, brightness, and color\nmanipulation options, as shown in Figures 3.2 and 3.7.\nExercises 3.1, 3.5, and 3.6 have you implement some of these operations, in order to\nbecome familiar with basic image processing operators. More sophisticated techniques for\ntonal adjustment (Reinhard, Ward, Pattanaik et al. 2005; Bae, Paris, and Durand 2006) are\ndescribed in the section on high dynamic range tone mapping (Section 10.2.1).\n3.2 Linear ﬁltering\nLocally adaptive histogram equalization is an example of a neighborhood operator or local\noperator, which uses a collection of pixel values in the vicinity of a given pixel to deter-\nmine its ﬁnal output value (Figure 3.10). In addition to performing local tone adjustment,\nneighborhood operators can be used to ﬁlter images in order to add soft blur, sharpen de-\ntails, accentuate edges, or remove noise (Figure 3.11b–d). In this section, we look at linear\nﬁltering operators, which involve weighted combinations of pixels in small neighborhoods.\nIn Section 3.3, we look at non-linear operators such as morphological ﬁlters and distance\ntransforms.\nThe most commonly used type of neighborhood operator is a linear ﬁlter, in which an\noutput pixel’s value is determined as a weighted sum of input pixel values (Figure 3.10),\ng(i, j) =\nX\nk,l\nf(i + k, j + l)h(k, l).\n(3.12)\nThe entries in the weight kernel or mask h(k, l) are often called the ﬁlter coefﬁcients. The\nabove correlation operator can be more compactly notated as\ng = f ⊗h.\n(3.13)\nA common variant on this formula is\ng(i, j) =\nX\nk,l\nf(i −k, j −l)h(k, l) =\nX\nk,l\nf(k, l)h(i −k, j −l),\n(3.14)",
  "image_path": "page_132.jpg",
  "pages": [
    131,
    132,
    133
  ]
}