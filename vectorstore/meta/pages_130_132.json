{
  "doc_id": "pages_130_132",
  "text": "108\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\n0\n1000\n2000\n3000\n4000\n5000\n6000\n0\n50\n100\n150\n200\n250\nB\nG\nR\nY\n0\n50000\n100000\n150000\n200000\n250000\n300000\n350000\n0\n50\n100\n150\n200\n250\nB\nG\nR\nY\n(a)\n(b)\n(c)\n0\n50\n100\n150\n200\n250\n0\n50\n100\n150\n200\n250\nB\nG\nR\nY\n(d)\n(e)\n(f)\nFigure 3.7 Histogram analysis and equalization: (a) original image (b) color channel and in-\ntensity (luminance) histograms; (c) cumulative distribution functions; (d) equalization (trans-\nfer) functions; (e) full histogram equalization; (f) partial histogram equalization.\ndark values and darken some light values, while still using the full extent of the available\ndynamic range? Can you think of a mapping that might do this?\nOne popular answer to this question is to perform histogram equalization, i.e., to ﬁnd\nan intensity mapping function f(I) such that the resulting histogram is ﬂat. The trick to\nﬁnding such a mapping is the same one that people use to generate random samples from\na probability density function, which is to ﬁrst compute the cumulative distribution function\nshown in Figure 3.7c.\nThink of the original histogram h(I) as the distribution of grades in a class after some\nexam. How can we map a particular grade to its corresponding percentile, so that students at\nthe 75% percentile range scored better than 3/4 of their classmates? The answer is to integrate\nthe distribution h(I) to obtain the cumulative distribution c(I),\nc(I) = 1\nN\nI\nX\ni=0\nh(i) = c(I −1) + 1\nN h(I),\n(3.9)\nwhere N is the number of pixels in the image or students in the class. For any given grade or\nintensity, we can look up its corresponding percentile c(I) and determine the ﬁnal value that\npixel should take. When working with eight-bit pixel values, the I and c axes are rescaled\nfrom [0, 255].\n3.1 Point operators\n109\n(a)\n(b)\n(c)\nFigure 3.8 Locally adaptive histogram equalization: (a) original image; (b) block histogram\nequalization; (c) full locally adaptive equalization.\nFigure 3.7d shows the result of applying f(I) = c(I) to the original image. As we\ncan see, the resulting histogram is ﬂat; so is the resulting image (it is “ﬂat” in the sense\nof a lack of contrast and being muddy looking). One way to compensate for this is to only\npartially compensate for the histogram unevenness, e.g., by using a mapping function f(I) =\nαc(I) + (1 −α)I, which is a linear blend between the cumulative distribution function and\nthe identity transform (a straight line). As you can see in Figure 3.7e, the resulting image\nmaintains more of its original grayscale distribution while having a more appealing balance.\nAnother potential problem with histogram equalization (or, in general, image brightening)\nis that noise in dark regions can be ampliﬁed and become more visible. Exercise 3.6 suggests\nsome possible ways to mitigate this, as well as alternative techniques to maintain contrast and\n“punch” in the original images (Larson, Rushmeier, and Piatko 1997; Stark 2000).\nLocally adaptive histogram equalization\nWhile global histogram equalization can be useful, for some images it might be preferable\nto apply different kinds of equalization in different regions. Consider for example the image\nin Figure 3.8a, which has a wide range of luminance values. Instead of computing a single\ncurve, what if we were to subdivide the image into M ×M pixel blocks and perform separate\nhistogram equalization in each sub-block? As you can see in Figure 3.8b, the resulting image\nexhibits a lot of blocking artifacts, i.e., intensity discontinuities at block boundaries.\nOne way to eliminate blocking artifacts is to use a moving window, i.e., to recompute the\nhistogram for every M × M block centered at each pixel. This process can be quite slow\n(M 2 operations per pixel), although with clever programming only the histogram entries\ncorresponding to the pixels entering and leaving the block (in a raster scan across the image)\nneed to be updated (M operations per pixel). Note that this operation is an example of the\nnon-linear neighborhood operations we study in more detail in Section 3.3.1.\nA more efﬁcient approach is to compute non-overlapped block-based equalization func-\ntions as before, but to then smoothly interpolate the transfer functions as we move between\n110\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nt\ns\nt\ns\n(a)\n(b)\nFigure 3.9 Local histogram interpolation using relative (s, t) coordinates: (a) block-based\nhistograms, with block centers shown as circles; (b) corner-based “spline” histograms. Pixels\nare located on grid intersections. The black square pixel’s transfer function is interpolated\nfrom the four adjacent lookup tables (gray arrows) using the computed (s, t) values. Block\nboundaries are shown as dashed lines.\nblocks. This technique is known as adaptive histogram equalization (AHE) and its contrast-\nlimited (gain-limited) version is known as CLAHE (Pizer, Amburn, Austin et al. 1987).3 The\nweighting function for a given pixel (i, j) can be computed as a function of its horizontal\nand vertical position (s, t) within a block, as shown in Figure 3.9a. To blend the four lookup\nfunctions {f00, . . . , f11}, a bilinear blending function,\nfs,t(I) = (1 −s)(1 −t)f00(I) + s(1 −t)f10(I) + (1 −s)tf01(I) + stf11(I)\n(3.10)\ncan be used. (See Section 3.5.2 for higher-order generalizations of such spline functions.)\nNote that instead of blending the four lookup tables for each output pixel (which would be\nquite slow), we can instead blend the results of mapping a given pixel through the four neigh-\nboring lookups.\nA variant on this algorithm is to place the lookup tables at the corners of each M × M\nblock (see Figure 3.9b and Exercise 3.7). In addition to blending four lookups to compute the\nﬁnal value, we can also distribute each input pixel into four adjacent lookup tables during the\nhistogram accumulation phase (notice that the gray arrows in Figure 3.9b point both ways),\ni.e.,\nhk,l(I(i, j)) += w(i, j, k, l),\n(3.11)\nwhere w(i, j, k, l) is the bilinear weighting function between pixel (i, j) and lookup table\n(k, l). This is an example of soft histogramming, which is used in a variety of other applica-\n3This algorithm is implemented in the MATLAB adapthist function.",
  "image_path": "page_131.jpg",
  "pages": [
    130,
    131,
    132
  ]
}