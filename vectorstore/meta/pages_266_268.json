{
  "doc_id": "pages_266_268",
  "text": "244\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nmethods.\nCombining edge feature cues\nIf the goal of edge detection is to match human boundary detection performance (Bowyer,\nKranenburg, and Dougherty 2001; Martin, Fowlkes, and Malik 2004; Arbel´aez, Maire, Fowlkes\net al. 2010), as opposed to simply ﬁnding stable features for matching, even better detectors\ncan be constructed by combining multiple low-level cues such as brightness, color, and tex-\nture.\nMartin, Fowlkes, and Malik (2004) describe a system that combines brightness, color, and\ntexture edges to produce state-of-the-art performance on a database of hand-segmented natu-\nral color images (Martin, Fowlkes, Tal et al. 2001). First, they construct and train8 separate\noriented half-disc detectors for measuring signiﬁcant differences in brightness (luminance),\ncolor (a* and b* channels, summed responses), and texture (un-normalized ﬁlter bank re-\nsponses from the work of Malik, Belongie, Leung et al. (2001)). Some of the responses\nare then sharpened using a soft non-maximal suppression technique. Finally, the outputs of\nthe three detectors are combined using a variety of machine-learning techniques, from which\nlogistic regression is found to have the best tradeoff between speed, space and accuracy .\nThe resulting system (see Figure 4.33 for some examples) is shown to outperform previously\ndeveloped techniques. Maire, Arbelaez, Fowlkes et al. (2008) improve on these results by\ncombining the detector based on local appearance with a spectral (segmentation-based) de-\ntector (Belongie and Malik 1998). In more recent work, Arbel´aez, Maire, Fowlkes et al.\n(2010) build a hierarchical segmentation on top of this edge detector using a variant of the\nwatershed algorithm.\n4.2.2 Edge linking\nWhile isolated edges can be useful for a variety of applications, such as line detection (Sec-\ntion 4.3) and sparse stereo matching (Section 11.2), they become even more useful when\nlinked into continuous contours.\nIf the edges have been detected using zero crossings of some function, linking them up\nis straightforward, since adjacent edgels share common endpoints. Linking the edgels into\nchains involves picking up an unlinked edgel and following its neighbors in both directions.\nEither a sorted list of edgels (sorted ﬁrst by x coordinates and then by y coordinates, for\nexample) or a 2D array can be used to accelerate the neighbor ﬁnding. If edges were not\ndetected using zero crossings, ﬁnding the continuation of an edgel can be tricky. In this\ncase, comparing the orientation (and, optionally, phase) of adjacent edgels can be used for\n8 The training uses 200 labeled images and testing is performed on a different set of 100 images.\n4.2 Edges\n245\nFigure 4.33\nCombined brightness, color, texture boundary detector (Martin, Fowlkes, and\nMalik 2004) c⃝2004 IEEE. Successive rows show the outputs of the brightness gradient\n(BG), color gradient (CG), texture gradient (TG), and combined (BG+CG+TG) detectors.\nThe ﬁnal row shows human-labeled boundaries derived from a database of hand-segmented\nimages (Martin, Fowlkes, Tal et al. 2001).\n246\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nN   0\nN   0\nW\n6\nNE  \n     1\n      7\nNW\nSW  \n     5\nFigure 4.34\nChain code representation of a grid-aligned linked edge chain. The code is\nrepresented as a series of direction codes, e.g, 0 1 0 7 6 5, which can further be compressed\nusing predictive and run-length coding.\ndisambiguation. Ideas from connected component computation can also sometimes be used\nto make the edge linking process even faster (see Exercise 4.8).\nOnce the edgels have been linked into chains, we can apply an optional thresholding\nwith hysteresis to remove low-strength contour segments (Canny 1986). The basic idea of\nhysteresis is to set two different thresholds and allow a curve being tracked above the higher\nthreshold to dip in strength down to the lower threshold.\nLinked edgel lists can be encoded more compactly using a variety of alternative repre-\nsentations. A chain code encodes a list of connected points lying on an N8 grid using a\nthree-bit code corresponding to the eight cardinal directions (N, NE, E, SE, S, SW, W, NW)\nbetween a point and its successor (Figure 4.34). While this representation is more compact\nthan the original edgel list (especially if predictive variable-length coding is used), it is not\nvery suitable for further processing.\nA more useful representation is the arc length parameterization of a contour, x(s), where\ns denotes the arc length along a curve. Consider the linked set of edgels shown in Fig-\nure 4.35a. We start at one point (the dot at (1.0, 0.5) in Figure 4.35a) and plot it at coordinate\ns = 0 (Figure 4.35b). The next point at (2.0, 0.5) gets plotted at s = 1, and the next point\nat (2.5, 1.0) gets plotted at s = 1.7071, i.e., we increment s by the length of each edge seg-\nment. The resulting plot can be resampled on a regular (say, integral) s grid before further\nprocessing.\nThe advantage of the arc-length parameterization is that it makes matching and processing\n(e.g., smoothing) operations much easier. Consider the two curves describing similar shapes\nshown in Figure 4.36. To compare the curves, we ﬁrst subtract the average values x0 =\nR\ns x(s) from each descriptor. Next, we rescale each descriptor so that s goes from 0 to 1\ninstead of 0 to S, i.e., we divide x(s) by S. Finally, we take the Fourier transform of each",
  "image_path": "page_267.jpg",
  "pages": [
    266,
    267,
    268
  ]
}