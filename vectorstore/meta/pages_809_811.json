{
  "doc_id": "pages_809_811",
  "text": "C.2 Software\n787\nRobust PCA code, http://www.salle.url.edu/∼ftorre/papers/rpca2.html (De la Torre and\nBlack 2003).\nAppendix A.3: Non-linear least squares\nMINPACK, http://www.netlib.org/minpack/.\nlevmar: Levenberg–Marquardt nonlinear least squares algorithms, http://www.ics.forth.\ngr/∼lourakis/levmar/ (Madsen, Nielsen, and Tingleff 2004).\nAppendix A.4–A.5: Direct and iterative sparse matrix solvers\nSuiteSparse (various reordering algorithms, CHOLMOD) and SuiteSparse QR, http:\n//www.cise.uﬂ.edu/research/sparse/SuiteSparse/ (Davis 2006, 2008).\nPARDISO (iterative and sparse direct solution), http://www.pardiso-project.org/.\nTAUCS (sparse direct, iterative, out of core, preconditioners), http://www.tau.ac.il/\n∼stoledo/taucs/.\nHSL Mathematical Software Library, http://www.hsl.rl.ac.uk/index.html.\nTemplates for the solution of linear systems, http://www.netlib.org/linalg/html templates/\nTemplates.html (Barrett, Berry, Chan et al. 1994). Download the PDF for instructions\non how to get the software.\nITSOL, MIQR, and other sparse solvers, http://www-users.cs.umn.edu/∼saad/software/\n(Saad 2003).\nILUPACK, http://www-public.tu-bs.de/∼bolle/ilupack/.\nAppendix B: Bayesian modeling and inference\nMiddlebury source code for MRF minimization, http://vision.middlebury.edu/MRF/\ncode/ (Szeliski, Zabih, Scharstein et al. 2008).\nC++ code for efﬁcient belief propagation for early vision, http://people.cs.uchicago.\nedu/∼pff/bp/ (Felzenszwalb and Huttenlocher 2006).\nFastPD MRF optimization code, http://www.csd.uoc.gr/∼komod/FastPD (Komodakis\nand Tziritas 2007a; Komodakis, Tziritas, and Paragios 2008)\n788\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\ndouble urand()\n{\nreturn ((double) rand()) / ((double) RAND MAX);\n}\nvoid grand(double& g1, double& g2)\n{\n#ifndef M PI\n#define M PI 3.14159265358979323846\n#endif // M PI\ndouble n1 = urand();\ndouble n2 = urand();\ndouble x1 = n1 + (n1 == 0); /* guard against log(0) */\ndouble sqlogn1 = sqrt(-2.0 * log (x1));\ndouble angl = (2.0 * M PI) * n2;\ng1 = sqlogn1 * cos(angl);\ng2 = sqlogn1 * sin(angl);\n}\nAlgorithm C.1 C algorithm for Gaussian random noise generation, using the Box–Muller\ntransform.\nGaussian noise generation.\nA lot of basic software packages come with a uniform random\nnoise generator (e.g., the rand() routine in Unix), but not all have a Gaussian random\nnoise generator. To compute a normally distributed random variable, you can use the Box–\nMuller transform (Box and Muller 1958), whose C code is given in Algorithm C.1—note that\nthis routine returns pairs of random variables. Alternative methods for generating Gaussian\nrandom numbers are given by Thomas, Luk, Leong et al. (2007).\nPseudocolor generation.\nIn many applications, it is convenient to be able to visualize the\nset of labels assigned to an image (or to image features such as lines). One of the easiest\nways to do this is to assign a unique color to each integer label. In my work, I have found it\nconvenient to distribute these labels in a quasi-uniform fashion around the RGB color cube\nusing the following idea.\nFor each (non-negative) label value, consider the bits as being split among the three color\nchannels, e.g., for a nine-bit value, the bits could be labeled RGBRGBRGB. After collecting\neach of the three color values, reverse the bits so that the low-order bits vary the most quickly.\nC.3 Slides and lectures\n789\nIn practice, for eight-bit color channels, this bit reverse can be stored in a table or a complete\ntable mapping from labels to pseudocolors (say with 4092 entries) can be pre-computed.\nFigure 8.16 shows an example of such a pseudo-color mapping.\nGPU implementation\nThe advent of programmable GPUs with capabilities such as pixel shaders and compute\nshaders has led to the development of fast computer vision algorithms for real-time appli-\ncations such as segmentation, tracking, stereo, and motion estimation (Pock, Unger, Cremers\net al. 2008; Vineet and Narayanan 2008; Zach, Gallup, and Frahm 2008). A good source\nfor learning about such algorithms is the CVPR 2008 workshop on Visual Computer Vision\non GPUs (CVGPU), http://www.cs.unc.edu/∼jmf/Workshop on Computer Vision on GPU.\nhtml, whose papers can be found on the CVPR 2008 proceedings DVD. Additional sources\nfor GPU algorithms include the GPGPU Web site and workshops, http://gpgpu.org/, and the\nOpenVIDIA Web site, http://openvidia.sourceforge.net/index.php/OpenVIDIA.\nC.3 Slides and lectures\nAs I mentioned in the preface, I hope to post slides corresponding to the material in the book.\nUntil these are ready, your best bet is to look at the slides from the courses I have co-taught\nat the University of Washington, as well as related courses that have used a similar syllabus.\nHere is a partial list of such courses:\nUW 455: Undergraduate Computer Vision, http://www.cs.washington.edu/education/\ncourses/455/.\nUW 576: Graduate Computer Vision, http://www.cs.washington.edu/education/courses/\n576/.\nStanford CS233B: Introduction to Computer Vision, http://vision.stanford.edu/teaching/\ncs223b/.\nMIT 6.869: Advances in Computer Vision, http://people.csail.mit.edu/torralba/courses/\n6.869/6.869.computervision.htm.\nBerkeley CS 280: Computer Vision, http://www.eecs.berkeley.edu/∼trevor/CS280.html.\nUNC COMP 776: Computer Vision, http://www.cs.unc.edu/∼lazebnik/spring10/.\nMiddlebury CS 453: Computer Vision, http://www.cs.middlebury.edu/∼schar/courses/\ncs453-s10/.",
  "image_path": "page_810.jpg",
  "pages": [
    809,
    810,
    811
  ]
}