{
  "doc_id": "pages_672_674",
  "text": "650\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\n13.7 Exercises\nEx 13.1: Depth image rendering\nDevelop a “view extrapolation” algorithm to re-render a\npreviously computed stereo depth map coupled with its corresponding reference color image.\n1. Use a 3D graphics mesh rendering system such as OpenGL or Direct3D, with two\ntriangles per pixel quad and perspective (projective) texture mapping (Debevec, Yu,\nand Borshukov 1998).\n2. Alternatively, use the one- or two-pass forward warper you constructed in Exercise 3.24,\nextended using (2.68–2.70) to convert from disparities or depths into displacements.\n3. (Optional) Kinks in straight lines introduced during view interpolation or extrapola-\ntion are visually noticeable, which is one reason why image morphing systems let you\nspecify line correspondences (Beier and Neely 1992). Modify your depth estimation\nalgorithm to match and estimate the geometry of straight lines and incorporate it into\nyour image-based rendering algorithm.\nEx 13.2: View interpolation\nExtend the system you created in the previous exercise to ren-\nder two reference views and then blend the images using a combination of z-buffering, hole\nﬁling, and blending (morphing) to create the ﬁnal image (Section 13.1).\n1. (Optional) If the two source images have very different exposures, the hole-ﬁlled re-\ngions and the blended regions will have different exposures. Can you extend your\nalgorithm to mitigate this?\n2. (Optional) Extend your algorithm to perform three-way (trilinear) interpolation be-\ntween neighboring views. You can triangulate the reference camera poses and use\nbarycentric coordinates for the virtual camera in order to determine the blending weights.\nEx 13.3: View morphing\nModify your view interpolation algorithm to perform morphs be-\ntween views of a non-rigid object, such as a person changing expressions.\n1. Instead of using a pure stereo algorithm, use a general ﬂow algorithm to compute dis-\nplacements, but separate them into a rigid displacement due to camera motion and a\nnon-rigid deformation.\n2. At render time, use the rigid geometry to determine the new pixel location but then add\na fraction of the non-rigid displacement as well.\n3. Alternatively, compute a stereo depth map but let the user specify additional correspon-\ndences or use a feature-based matching algorithm to provide them automatically.\n13.7 Exercises\n651\n4. (Optional) Take a single image, such as the Mona Lisa or a friend’s picture, and create\nan animated 3D view morph (Seitz and Dyer 1996).\n(a) Find the vertical axis of symmetry in the image and reﬂect your reference image\nto provide a virtual pair (assuming the person’s hairstyle is somewhat symmetric).\n(b) Use structure from motion to determine the relative camera pose of the pair.\n(c) Use dense stereo matching to estimate the 3D shape.\n(d) Use view morphing to create a 3D animation.\nEx 13.4: View dependent texture mapping\nUse a 3D model you created along with the\noriginal images to implement a view-dependent texture mapping system.\n1. Use one of the 3D reconstruction techniques you developed in Exercises 7.3, 11.9,\n11.10, or 12.8 to build a triangulated 3D image-based model from multiple photographs.\n2. Extract textures for each model face from your photographs, either by performing the\nappropriate resampling or by ﬁguring out how to use the texture mapping software to\ndirectly access the source images.\n3. At run time, for each new camera view, select the best source image for each visible\nmodel face.\n4. Extend this to blend between the top two or three textures. This is trickier, since it\ninvolves the use of texture blending or pixel shading (Debevec, Taylor, and Malik 1996;\nDebevec, Yu, and Borshukov 1998; Pighin, Hecker, Lischinski et al. 1998).\nEx 13.5: Layered depth images\nExtend your view interpolation algorithm (Exercise 13.2)\nto store more than one depth or color value per pixel (Shade, Gortler, He et al. 1998), i.e., a\nlayered depth image (LDI). Modify your rendering algorithm accordingly. For your data, you\ncan use synthetic ray tracing, a layered reconstructed model, or a volumetric reconstruction.\nEx 13.6: Rendering from sprites or layers\nExtend your view interpolation algorithm to\nhandle multiple planes or sprites (Section 13.2.1) (Shade, Gortler, He et al. 1998).\n1. Extract your layers using the technique you developed in Exercise 8.9.\n2. Alternatively, use an interactive painting and 3D placement system to extract your lay-\ners (Kang 1998; Oh, Chen, Dorsey et al. 2001; Shum, Sun, Yamazaki et al. 2004).\n3. Determine a back-to-front order based on expected visibility or add a z-buffer to your\nrendering algorithm to handle occlusions.\n652\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\n4. Render and composite all of the resulting layers, with optional alpha matting to handle\nthe edges of layers and sprites.\nEx 13.7: Light ﬁeld transformations\nDerive the equations relating regular images to 4D\nlight ﬁeld coordinates.\n1. Determine the mapping between the far plane (u, v) coordinates and a virtual camera’s\n(x, y) coordinates.\n(a) Start by parameterizing a 3D point on the uv plane in terms of its (u, v) coordi-\nnates.\n(b) Project the resulting 3D point to the camera pixels (x, y, 1) using the usual 3 × 4\ncamera matrix P (2.63).\n(c) Derive the 2D homography relating (u, v) and (x, y) coordinates.\n2. Write down a similar transformation for (s, t) to (x, y) coordinates.\n3. Prove that if the virtual camera is actually on the (s, t) plane, the (s, t) value depends\nonly on the camera’s optical center and is independent of (x, y).\n4. Prove that an image taken by a regular orthographic or perspective camera, i.e., one that\nhas a linear projective relationship between 3D points and (x, y) pixels (2.63), samples\nthe (s, t, u, v) light ﬁeld along a two-dimensional hyperplane.\nEx 13.8: Light ﬁeld and Lumigraph rendering\nImplement a light ﬁeld or Lumigraph ren-\ndering system:\n1. Download one of the light ﬁeld data sets from http://lightﬁeld.stanford.edu/.\n2. Write an algorithm to synthesize a new view from this light ﬁeld, using quadri-linear\ninterpolation of (s, t, u, v) ray samples.\n3. Try varying the focal plane corresponding to your desired view (Isaksen, McMillan,\nand Gortler 2000) and see if the resulting image looks sharper.\n4. Determine a 3D proxy for the objects in your scene. You can do this by running multi-\nview stereo over one of your light ﬁelds to obtain a depth map per image.\n5. Implement the Lumigraph rendering algorithm, which modiﬁes the sampling of rays\naccording to the 3D location of each surface element.\n6. Collect a set of images yourself and determine their pose using structure from motion.",
  "image_path": "page_673.jpg",
  "pages": [
    672,
    673,
    674
  ]
}