{
  "doc_id": "pages_284_286",
  "text": "262\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nstruct SEdgel {\nfloat e[2][2];\n// edgel endpoints (zero crossing)\nfloat x, y;\n// sub-pixel edge position (midpoint)\nfloat n_x, n_y;\n// orientation, as normal vector\nfloat theta;\n// orientation, as angle (degrees)\nfloat length;\n// length of edgel\nfloat strength;\n// strength of edgel (gradient magnitude)\n};\nstruct SLine : public SEdgel {\nfloat line_length;\n// length of line (est. from ellipsoid)\nfloat sigma;\n// estimated std. dev. of edgel noise\nfloat r;\n// line equation: x * n_y - y * n_x = r\n};\nFigure 4.48 A potential C++ structure for edgel and line elements.\n4. For each quad of pixels, {(i, j), (i + 1, j), (i, j + 1), (i + 1, j + 1)}, count the number\nof zero crossings along the four edges.\n5. When there are exactly two zero crossings, compute their locations using (4.25) and\nstore these edgel endpoints along with the midpoint in the edgel structure (Figure 4.48).\n6. For each edgel, compute the local gradient by taking the horizontal and vertical differ-\nences between the values of S along the zero crossing edges.\n7. Store the magnitude of this gradient as the edge strength and either its orientation or\nthat of the segment joining the edgel endpoints as the edge orientation.\n8. Add the edgel to a list of edgels or store it in a 2D array of edgels (addressed by pixel\ncoordinates).\nFigure 4.48 shows a possible representation for each computed edgel.\nEx 4.8: Edge linking and thresholding\nLink up the edges computed in the previous exer-\ncise into chains and optionally perform thresholding with hysteresis.\nThe steps may include:\n1. Store the edgels either in a 2D array (say, an integer image with indices into the edgel\nlist) or pre-sort the edgel list ﬁrst by (integer) x coordinates and then y coordinates, for\nfaster neighbor ﬁnding.\n4.5 Exercises\n263\n2. Pick up an edgel from the list of unlinked edgels and ﬁnd its neighbors in both direc-\ntions until no neighbor is found or a closed contour is obtained. Flag edgels as linked\nas you visit them and push them onto your list of linked edgels.\n3. Alternatively, generalize a previously developed connected component algorithm (Ex-\nercise 3.14) to perform the linking in just two raster passes.\n4. (Optional) Perform hysteresis-based thresholding (Canny 1986). Use two thresholds\n”hi” and ”lo” for the edge strength. A candidate edgel is considered an edge if either\nits strength is above the ”hi” threshold or its strength is above the ”lo” threshold and it\nis (recursively) connected to a previously detected edge.\n5. (Optional) Link together contours that have small gaps but whose endpoints have sim-\nilar orientations.\n6. (Optional) Find junctions between adjacent contours, e.g., using some of the ideas (or\nreferences) from Maire, Arbelaez, Fowlkes et al. (2008).\nEx 4.9: Contour matching\nConvert a closed contour (linked edgel list) into its arc-length\nparameterization and use this to match object outlines.\nThe steps may include:\n1. Walk along the contour and create a list of (xi, yi, si) triplets, using the arc-length\nformula\nsi+1 = si + ∥xi+1 −xi∥.\n(4.32)\n2. Resample this list onto a regular set of (xj, yj, j) samples using linear interpolation of\neach segment.\n3. Compute the average values of x and y, i.e., x and y and subtract them from your\nsampled curve points.\n4. Resample the original (xi, yi, si) piecewise-linear function onto a length-independent\nset of samples, say j ∈[0, 1023]. (Using a length which is a power of two makes\nsubsequent Fourier transforms more convenient.)\n5. Compute the Fourier transform of the curve, treating each (x, y) pair as a complex\nnumber.\n6. To compare two curves, ﬁt a linear equation to the phase difference between the two\ncurves. (Careful: phase wraps around at 360◦. Also, you may wish to weight samples\nby their Fourier spectrum magnitude—see Section 8.1.2.)\n264\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\n7. (Optional) Prove that the constant phase component corresponds to the temporal shift\nin s, while the linear component corresponds to rotation.\nOf course, feel free to try any other curve descriptor and matching technique from the com-\nputer vision literature (Tek and Kimia 2003; Sebastian and Kimia 2005).\nEx 4.10: Jigsaw puzzle solver—challenging\nWrite a program to automatically solve a jig-\nsaw puzzle from a set of scanned puzzle pieces. Your software may include the following\ncomponents:\n1. Scan the pieces (either face up or face down) on a ﬂatbed scanner with a distinctively\ncolored background.\n2. (Optional) Scan in the box top to use as a low-resolution reference image.\n3. Use color-based thresholding to isolate the pieces.\n4. Extract the contour of each piece using edge ﬁnding and linking.\n5. (Optional) Re-represent each contour using an arc-length or some other re-parameterization.\nBreak up the contours into meaningful matchable pieces. (Is this hard?)\n6. (Optional) Associate color values with each contour to help in the matching.\n7. (Optional) Match pieces to the reference image using some rotationally invariant fea-\nture descriptors.\n8. Solve a global optimization or (backtracking) search problem to snap pieces together\nand place them in the correct location relative to the reference image.\n9. Test your algorithm on a succession of more difﬁcult puzzles and compare your results\nwith those of others.\nEx 4.11: Successive approximation line detector\nImplement a line simpliﬁcation algorithm\n(Section 4.3.1) (Ramer 1972; Douglas and Peucker 1973) to convert a hand-drawn curve (or\nlinked edge image) into a small set of polylines.\n(Optional) Re-render this curve using either an approximating or interpolating spline or\nBezier curve (Szeliski and Ito 1986; Bartels, Beatty, and Barsky 1987; Farin 1996).\nEx 4.12: Hough transform line detector\nImplement a Hough transform for ﬁnding lines\nin images:",
  "image_path": "page_285.jpg",
  "pages": [
    284,
    285,
    286
  ]
}