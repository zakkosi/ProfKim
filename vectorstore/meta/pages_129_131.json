{
  "doc_id": "pages_129_131",
  "text": "3.1 Point operators\n107\nFigure 3.6 An example of light reﬂecting off the transparent glass of a picture frame (Black\nand Anandan 1996) c⃝1996 Elsevier. You can clearly see the woman’s portrait inside the\npicture frame superimposed with the reﬂection of a man’s face off the glass.\nSmith and Blinn (1996) have a nice survey of traditional blue-screen matting techniques,\nwhile Toyama, Krumm, Brumitt et al. (1999) review difference matting. More recently, there\nhas been a lot of activity in computational photography relating to natural image matting\n(Ruzon and Tomasi 2000; Chuang, Curless, Salesin et al. 2001; Wang and Cohen 2007a),\nwhich attempts to extract the mattes from a single natural image (Figure 3.4a) or from ex-\ntended video sequences (Chuang, Agarwala, Curless et al. 2002). All of these techniques are\ndescribed in more detail in Section 10.4.\n3.1.4 Histogram equalization\nWhile the brightness and gain controls described in Section 3.1.1 can improve the appearance\nof an image, how can we automatically determine their best values? One approach might\nbe to look at the darkest and brightest pixel values in an image and map them to pure black\nand pure white. Another approach might be to ﬁnd the average value in the image, push it\ntowards middle gray, and expand the range so that it more closely ﬁlls the displayable values\n(Kopf, Uyttendaele, Deussen et al. 2007).\nHow can we visualize the set of lightness values in an image in order to test some of\nthese heuristics? The answer is to plot the histogram of the individual color channels and\nluminance values, as shown in Figure 3.7b.2 From this distribution, we can compute relevant\nstatistics such as the minimum, maximum, and average intensity values. Notice that the image\nin Figure 3.7a has both an excess of dark values and light values, but that the mid-range values\nare largely under-populated. Would it not be better if we could simultaneously brighten some\n2 The histogram is simply the count of the number of pixels at each gray level value. For an eight-bit image, an\naccumulation table with 256 entries is needed. For higher bit depths, a table with the appropriate number of entries\n(probably fewer than the full number of gray levels) should be used.\n108\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\n0\n1000\n2000\n3000\n4000\n5000\n6000\n0\n50\n100\n150\n200\n250\nB\nG\nR\nY\n0\n50000\n100000\n150000\n200000\n250000\n300000\n350000\n0\n50\n100\n150\n200\n250\nB\nG\nR\nY\n(a)\n(b)\n(c)\n0\n50\n100\n150\n200\n250\n0\n50\n100\n150\n200\n250\nB\nG\nR\nY\n(d)\n(e)\n(f)\nFigure 3.7 Histogram analysis and equalization: (a) original image (b) color channel and in-\ntensity (luminance) histograms; (c) cumulative distribution functions; (d) equalization (trans-\nfer) functions; (e) full histogram equalization; (f) partial histogram equalization.\ndark values and darken some light values, while still using the full extent of the available\ndynamic range? Can you think of a mapping that might do this?\nOne popular answer to this question is to perform histogram equalization, i.e., to ﬁnd\nan intensity mapping function f(I) such that the resulting histogram is ﬂat. The trick to\nﬁnding such a mapping is the same one that people use to generate random samples from\na probability density function, which is to ﬁrst compute the cumulative distribution function\nshown in Figure 3.7c.\nThink of the original histogram h(I) as the distribution of grades in a class after some\nexam. How can we map a particular grade to its corresponding percentile, so that students at\nthe 75% percentile range scored better than 3/4 of their classmates? The answer is to integrate\nthe distribution h(I) to obtain the cumulative distribution c(I),\nc(I) = 1\nN\nI\nX\ni=0\nh(i) = c(I −1) + 1\nN h(I),\n(3.9)\nwhere N is the number of pixels in the image or students in the class. For any given grade or\nintensity, we can look up its corresponding percentile c(I) and determine the ﬁnal value that\npixel should take. When working with eight-bit pixel values, the I and c axes are rescaled\nfrom [0, 255].\n3.1 Point operators\n109\n(a)\n(b)\n(c)\nFigure 3.8 Locally adaptive histogram equalization: (a) original image; (b) block histogram\nequalization; (c) full locally adaptive equalization.\nFigure 3.7d shows the result of applying f(I) = c(I) to the original image. As we\ncan see, the resulting histogram is ﬂat; so is the resulting image (it is “ﬂat” in the sense\nof a lack of contrast and being muddy looking). One way to compensate for this is to only\npartially compensate for the histogram unevenness, e.g., by using a mapping function f(I) =\nαc(I) + (1 −α)I, which is a linear blend between the cumulative distribution function and\nthe identity transform (a straight line). As you can see in Figure 3.7e, the resulting image\nmaintains more of its original grayscale distribution while having a more appealing balance.\nAnother potential problem with histogram equalization (or, in general, image brightening)\nis that noise in dark regions can be ampliﬁed and become more visible. Exercise 3.6 suggests\nsome possible ways to mitigate this, as well as alternative techniques to maintain contrast and\n“punch” in the original images (Larson, Rushmeier, and Piatko 1997; Stark 2000).\nLocally adaptive histogram equalization\nWhile global histogram equalization can be useful, for some images it might be preferable\nto apply different kinds of equalization in different regions. Consider for example the image\nin Figure 3.8a, which has a wide range of luminance values. Instead of computing a single\ncurve, what if we were to subdivide the image into M ×M pixel blocks and perform separate\nhistogram equalization in each sub-block? As you can see in Figure 3.8b, the resulting image\nexhibits a lot of blocking artifacts, i.e., intensity discontinuities at block boundaries.\nOne way to eliminate blocking artifacts is to use a moving window, i.e., to recompute the\nhistogram for every M × M block centered at each pixel. This process can be quite slow\n(M 2 operations per pixel), although with clever programming only the histogram entries\ncorresponding to the pixels entering and leaving the block (in a raster scan across the image)\nneed to be updated (M operations per pixel). Note that this operation is an example of the\nnon-linear neighborhood operations we study in more detail in Section 3.3.1.\nA more efﬁcient approach is to compute non-overlapped block-based equalization func-\ntions as before, but to then smoothly interpolate the transfer functions as we move between",
  "image_path": "page_130.jpg",
  "pages": [
    129,
    130,
    131
  ]
}