{
  "doc_id": "pages_138_140",
  "text": "116\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\n1\nK2\n1\n1\n· · ·\n1\n1\n1\n· · ·\n1\n...\n...\n1\n...\n1\n1\n· · ·\n1\n1\n16\n1\n2\n1\n2\n4\n2\n1\n2\n1\n1\n256\n1\n4\n6\n4\n1\n4\n16\n24\n16\n4\n6\n24\n36\n24\n6\n4\n16\n24\n16\n4\n1\n4\n6\n4\n1\n1\n8\n−1\n0\n1\n−2\n0\n2\n−1\n0\n1\n1\n4\n1\n−2\n1\n−2\n4\n−2\n1\n−2\n1\n1\nK\n1\n1\n· · ·\n1\n1\n4\n1\n2\n1\n1\n16\n1\n4\n6\n4\n1\n1\n2\n−1\n0\n1\n1\n2\n1\n−2\n1\n(a) box, K = 5\n(b) bilinear\n(c) “Gaussian”\n(d) Sobel\n(e) corner\nFigure 3.14\nSeparable linear ﬁlters: For each image (a)–(e), we show the 2D ﬁlter kernel\n(top), the corresponding horizontal 1D kernel (middle), and the ﬁltered image (bottom). The\nﬁltered Sobel and corner images are signed, scaled up by 2× and 4×, respectively, and added\nto a gray offset before display.\nure 3.14a. In many cases, this operation can be signiﬁcantly sped up by ﬁrst performing a\none-dimensional horizontal convolution followed by a one-dimensional vertical convolution\n(which requires a total of 2K operations per pixel). A convolution kernel for which this is\npossible is said to be separable.\nIt is easy to show that the two-dimensional kernel K corresponding to successive con-\nvolution with a horizontal kernel h and a vertical kernel v is the outer product of the two\nkernels,\nK = vhT\n(3.20)\n(see Figure 3.14 for some examples). Because of the increased efﬁciency, the design of\nconvolution kernels for computer vision applications is often inﬂuenced by their separability.\nHow can we tell if a given kernel K is indeed separable? This can often be done by\ninspection or by looking at the analytic form of the kernel (Freeman and Adelson 1991). A\nmore direct method is to treat the 2D kernel as a 2D matrix K and to take its singular value\ndecomposition (SVD),\nK =\nX\ni\nσiuivT\ni\n(3.21)\n(see Appendix A.1.1 for the deﬁnition of the SVD). If only the ﬁrst singular value σ0 is\nnon-zero, the kernel is separable and √σ0u0 and √σ0vT\n0 provide the vertical and horizontal\n3.2 Linear ﬁltering\n117\nkernels (Perona 1995). For example, the Laplacian of Gaussian kernel (3.26 and 4.23) can be\nimplemented as the sum of two separable ﬁlters (4.24) (Wiejak, Buxton, and Buxton 1985).\nWhat if your kernel is not separable and yet you still want a faster way to implement\nit? Perona (1995), who ﬁrst made the link between kernel separability and SVD, suggests\nusing more terms in the (3.21) series, i.e., summing up a number of separable convolutions.\nWhether this is worth doing or not depends on the relative sizes of K and the number of sig-\nniﬁcant singular values, as well as other considerations, such as cache coherency and memory\nlocality.\n3.2.2 Examples of linear ﬁltering\nNow that we have described the process for performing linear ﬁltering, let us examine a\nnumber of frequently used ﬁlters.\nThe simplest ﬁlter to implement is the moving average or box ﬁlter, which simply averages\nthe pixel values in a K ×K window. This is equivalent to convolving the image with a kernel\nof all ones and then scaling (Figure 3.14a). For large kernels, a more efﬁcient implementation\nis to slide a moving window across each scanline (in a separable ﬁlter) while adding the\nnewest pixel and subtracting the oldest pixel from the running sum. This is related to the\nconcept of summed area tables, which we describe shortly.\nA smoother image can be obtained by separably convolving the image with a piecewise\nlinear “tent” function (also known as a Bartlett ﬁlter). Figure 3.14b shows a 3 × 3 version\nof this ﬁlter, which is called the bilinear kernel, since it is the outer product of two linear\n(ﬁrst-order) splines (see Section 3.5.2).\nConvolving the linear tent function with itself yields the cubic approximating spline,\nwhich is called the “Gaussian” kernel (Figure 3.14c) in Burt and Adelson’s (1983a) Lapla-\ncian pyramid representation (Section 3.5). Note that approximate Gaussian kernels can also\nbe obtained by iterated convolution with box ﬁlters (Wells 1986). In applications where the\nﬁlters really need to be rotationally symmetric, carefully tuned versions of sampled Gaussians\nshould be used (Freeman and Adelson 1991) (Exercise 3.10).\nThe kernels we just discussed are all examples of blurring (smoothing) or low-pass ker-\nnels (since they pass through the lower frequencies while attenuating higher frequencies).\nHow good are they at doing this? In Section 3.4, we use frequency-space Fourier analysis to\nexamine the exact frequency response of these ﬁlters. We also introduce the sinc ((sin x)/x)\nﬁlter, which performs ideal low-pass ﬁltering.\nIn practice, smoothing kernels are often used to reduce high-frequency noise. We have\nmuch more to say about using variants on smoothing to remove noise later (see Sections 3.3.1,\n3.4, and 3.7).\nSurprisingly, smoothing kernels can also be used to sharpen images using a process called\n118\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nunsharp masking.\nSince blurring the image reduces high frequencies, adding some of the\ndifference between the original and the blurred image makes it sharper,\ngsharp = f + γ(f −hblur ∗f).\n(3.22)\nIn fact, before the advent of digital photography, this was the standard way to sharpen images\nin the darkroom: create a blurred (“positive”) negative from the original negative by mis-\nfocusing, then overlay the two negatives before printing the ﬁnal image, which corresponds\nto\ngunsharp = f(1 −γhblur ∗f).\n(3.23)\nThis is no longer a linear ﬁlter but it still works well.\nLinear ﬁltering can also be used as a pre-processing stage to edge extraction (Section 4.2)\nand interest point detection (Section 4.1) algorithms. Figure 3.14d shows a simple 3 × 3 edge\nextractor called the Sobel operator, which is a separable combination of a horizontal central\ndifference (so called because the horizontal derivative is centered on the pixel) and a vertical\ntent ﬁlter (to smooth the results). As you can see in the image below the kernel, this ﬁlter\neffectively emphasizes horizontal edges.\nThe simple corner detector (Figure 3.14e) looks for simultaneous horizontal and vertical\nsecond derivatives. As you can see however, it responds not only to the corners of the square,\nbut also along diagonal edges. Better corner detectors, or at least interest point detectors that\nare more rotationally invariant, are described in Section 4.1.\n3.2.3 Band-pass and steerable ﬁlters\nThe Sobel and corner operators are simple examples of band-pass and oriented ﬁlters. More\nsophisticated kernels can be created by ﬁrst smoothing the image with a (unit area) Gaussian\nﬁlter,\nG(x, y; σ) =\n1\n2πσ2 e−x2+y2\n2σ2 ,\n(3.24)\nand then taking the ﬁrst or second derivatives (Marr 1982; Witkin 1983; Freeman and Adelson\n1991). Such ﬁlters are known collectively as band-pass ﬁlters, since they ﬁlter out both low\nand high frequencies.\nThe (undirected) second derivative of a two-dimensional image,\n∇2f = ∂2f\n∂x2 + ∂2y\n∂y2 ,\n(3.25)\nis known as the Laplacian operator. Blurring an image with a Gaussian and then taking its\nLaplacian is equivalent to convolving directly with the Laplacian of Gaussian (LoG) ﬁlter,\n∇2G(x, y; σ) =\n\u0012x2 + y2\nσ4\n−2\nσ2\n\u0013\nG(x, y; σ),\n(3.26)",
  "image_path": "page_139.jpg",
  "pages": [
    138,
    139,
    140
  ]
}