{
  "doc_id": "pages_066_068",
  "text": "44\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nz\nx\nw\n║q║=1\ny\nq0\nq1\nq2\n-q2\nFigure 2.6 Unit quaternions live on the unit sphere ∥q∥= 1. This ﬁgure shows a smooth\ntrajectory through the three quaternions q0, q1, and q2. The antipodal point to q2, namely\n−q2, represents the same rotation as q2.\nwhere ˆn and θ are the rotation axis and angle. Using the trigonometric identities sin θ =\n2 sin θ\n2 cos θ\n2 and (1 −cos θ) = 2 sin2 θ\n2, Rodriguez’s formula can be converted to\nR(ˆn, θ)\n=\nI + sin θ[ˆn]× + (1 −cos θ)[ˆn]2\n×\n=\nI + 2w[v]× + 2[v]2\n×.\n(2.40)\nThis suggests a quick way to rotate a vector v by a quaternion using a series of cross products,\nscalings, and additions. To obtain a formula for R(q) as a function of (x, y, z, w), recall that\n[v]× =\n\n\n0\n−z\ny\nz\n0\n−x\n−y\nx\n0\n\nand [v]2\n× =\n\n\n−y2 −z2\nxy\nxz\nxy\n−x2 −z2\nyz\nxz\nyz\n−x2 −y2\n\n.\nWe thus obtain\nR(q) =\n\n\n1 −2(y2 + z2)\n2(xy −zw)\n2(xz + yw)\n2(xy + zw)\n1 −2(x2 + z2)\n2(yz −xw)\n2(xz −yw)\n2(yz + xw)\n1 −2(x2 + y2)\n\n.\n(2.41)\nThe diagonal terms can be made more symmetrical by replacing 1 −2(y2 + z2) with (x2 +\nw2 −y2 −z2), etc.\nThe nicest aspect of unit quaternions is that there is a simple algebra for composing rota-\ntions expressed as unit quaternions. Given two quaternions q0 = (v0, w0) and q1 = (v1, w1),\nthe quaternion multiply operator is deﬁned as\nq2 = q0q1 = (v0 × v1 + w0v1 + w1v0, w0w1 −v0 · v1),\n(2.42)\n2.1 Geometric primitives and transformations\n45\nwith the property that R(q2) = R(q0)R(q1). Note that quaternion multiplication is not\ncommutative, just as 3D rotations and matrix multiplications are not.\nTaking the inverse of a quaternion is easy: Just ﬂip the sign of v or w (but not both!).\n(You can verify this has the desired effect of transposing the R matrix in (2.41).) Thus, we\ncan also deﬁne quaternion division as\nq2 = q0/q1 = q0q−1\n1\n= (v0 × v1 + w0v1 −w1v0, −w0w1 −v0 · v1).\n(2.43)\nThis is useful when the incremental rotation between two rotations is desired.\nIn particular, if we want to determine a rotation that is partway between two given rota-\ntions, we can compute the incremental rotation, take a fraction of the angle, and compute the\nnew rotation. This procedure is called spherical linear interpolation or slerp for short (Shoe-\nmake 1985) and is given in Algorithm 2.1. Note that Shoemake presents two formulas other\nthan the one given here. The ﬁrst exponentiates qr by alpha before multiplying the original\nquaternion,\nq2 = qα\nr q0,\n(2.44)\nwhile the second treats the quaternions as 4-vectors on a sphere and uses\nq2 = sin(1 −α)θ\nsin θ\nq0 + sin αθ\nsin θ q1,\n(2.45)\nwhere θ = cos−1(q0 · q1) and the dot product is directly between the quaternion 4-vectors.\nAll of these formulas give comparable results, although care should be taken when q0 and q1\nare close together, which is why I prefer to use an arctangent to establish the rotation angle.\nWhich rotation representation is better?\nThe choice of representation for 3D rotations depends partly on the application.\nThe axis/angle representation is minimal, and hence does not require any additional con-\nstraints on the parameters (no need to re-normalize after each update). If the angle is ex-\npressed in degrees, it is easier to understand the pose (say, 90◦twist around x-axis), and also\neasier to express exact rotations. When the angle is in radians, the derivatives of R with\nrespect to ω can easily be computed (2.36).\nQuaternions, on the other hand, are better if you want to keep track of a smoothly moving\ncamera, since there are no discontinuities in the representation. It is also easier to interpolate\nbetween rotations and to chain rigid transformations (Murray, Li, and Sastry 1994; Bregler\nand Malik 1998).\nMy usual preference is to use quaternions, but to update their estimates using an incre-\nmental rotation, as described in Section 6.2.2.\n46\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nprocedure slerp(q0, q1, α):\n1. qr = q1/q0 = (vr, wr)\n2. if wr < 0 then qr ←−qr\n3. θr = 2 tan−1(∥vr∥/wr)\n4. ˆnr = N(vr) = vr/∥vr∥\n5. θα = α θr\n6. qα = (sin θα\n2 ˆnr, cos θα\n2 )\n7. return q2 = qαq0\nAlgorithm 2.1 Spherical linear interpolation (slerp). The axis and total angle are ﬁrst com-\nputed from the quaternion ratio. (This computation can be lifted outside an inner loop that\ngenerates a set of interpolated position for animation.) An incremental quaternion is then\ncomputed and multiplied by the starting rotation quaternion.\n2.1.5 3D to 2D projections\nNow that we know how to represent 2D and 3D geometric primitives and how to transform\nthem spatially, we need to specify how 3D primitives are projected onto the image plane. We\ncan do this using a linear 3D to 2D projection matrix. The simplest model is orthography,\nwhich requires no division to get the ﬁnal (inhomogeneous) result. The more commonly used\nmodel is perspective, since this more accurately models the behavior of real cameras.\nOrthography and para-perspective\nAn orthographic projection simply drops the z component of the three-dimensional coordi-\nnate p to obtain the 2D point x. (In this section, we use p to denote 3D points and x to denote\n2D points.) This can be written as\nx = [I2×2|0] p.\n(2.46)\nIf we are using homogeneous (projective) coordinates, we can write\n˜x =\n\n\n1\n0\n0\n0\n0\n1\n0\n0\n0\n0\n0\n1\n\n˜p,\n(2.47)",
  "image_path": "page_067.jpg",
  "pages": [
    66,
    67,
    68
  ]
}