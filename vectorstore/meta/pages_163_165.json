{
  "doc_id": "pages_163_165",
  "text": "3.4 Fourier transforms\n141\nsample from a correlated Gaussian random noise ﬁeld combined with a statistical model of\nthe measurement process yields an optimum restoration ﬁlter known as the Wiener ﬁlter.11\nTo derive the Wiener ﬁlter, we analyze each frequency component of a signal’s Fourier\ntransform independently. The noisy image formation process can be written as\no(x, y) = s(x, y) + n(x, y),\n(3.66)\nwhere s(x, y) is the (unknown) image we are trying to recover, n(x, y) is the additive noise\nsignal, and o(x, y) is the observed noisy image. Because of the linearity of the Fourier trans-\nform, we can write\nO(ωx, ωy) = S(ωx, ωy) + N(ωx, ωy),\n(3.67)\nwhere each quantity in the above equation is the Fourier transform of the corresponding\nimage.\nAt each frequency (ωx, ωy), we know from our image spectrum that the unknown trans-\nform component S(ωx, ωy) has a prior distribution which is a zero-mean Gaussian with vari-\nance Ps(ωx, ωy). We also have noisy measurement O(ωx, ωy) whose variance is Pn(ωx, ωy),\ni.e., the power spectrum of the noise, which is usually assumed to be constant (white),\nPn(ωx, ωy) = σ2\nn.\nAccording to Bayes’ Rule (Appendix B.4), the posterior estimate of S can be written as\np(S|O) = p(O|S)p(S)\np(O)\n,\n(3.68)\nwhere p(O) =\nR\nS p(O|S)p(S) is a normalizing constant used to make the p(S|O) distribution\nproper (integrate to 1). The prior distribution p(S) is given by\np(S) = e−(S−µ)2\n2Ps\n,\n(3.69)\nwhere µ is the expected mean at that frequency (0 everywhere except at the origin) and the\nmeasurement distribution P(O|S) is given by\np(S) = e−(S−O)2\n2Pn\n.\n(3.70)\nTaking the negative logarithm of both sides of (3.68) and setting µ = 0 for simplicity, we\nget\n−log p(S|O)\n=\n−log p(O|S) −log p(S) + C\n(3.71)\n=\n1/2P −1\nn (S −O)2 + 1/2P −1\ns\nS2 + C,\n(3.72)\n11 Wiener is pronounced “veener” since, in German, the “w” is pronounced “v”. Remember that next time you\norder “Wiener schnitzel”.\n142\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nP\nn\nW\n(a)\n(b)\nFigure 3.25 One-dimensional Wiener ﬁlter: (a) power spectrum of signal Ps(f), noise level\nσ2, and Wiener ﬁlter transform W(f); (b) Wiener ﬁlter spatial kernel.\nwhich is the negative posterior log likelihood. The minimum of this quantity is easy to\ncompute,\nSopt =\nP −1\nn\nP −1\nn\n+ P −1\ns\nO =\nPs\nPs + Pn\nO =\n1\n1 + Pn/Ps\nO.\n(3.73)\nThe quantity\nW(ωx, ωy) =\n1\n1 + σ2n/Ps(ωx, ωy)\n(3.74)\nis the Fourier transform of the optimum Wiener ﬁlter needed to remove the noise from an\nimage whose power spectrum is Ps(ωx, ωy).\nNotice that this ﬁlter has the right qualitative properties, i.e., for low frequencies where\nPs ≫σ2\nn, it has unit gain, whereas for high frequencies, it attenuates the noise by a factor\nPs/σ2\nn. Figure 3.25 shows the one-dimensional transform W(f) and the corresponding ﬁlter\nkernel w(x) for the commonly assumed case of P(f) = f −2 (Field 1987). Exercise 3.16 has\nyou compare the Wiener ﬁlter as a denoising algorithm to hand-tuned Gaussian smoothing.\nThe methodology given above for deriving the Wiener ﬁlter can easily be extended to the\ncase where the observed image is a noisy blurred version of the original image,\no(x, y) = b(x, y) ∗s(x, y) + n(x, y),\n(3.75)\nwhere b(x, y) is the known blur kernel. Rather than deriving the corresponding Wiener ﬁl-\nter, we leave it as an exercise (Exercise 3.17), which also encourages you to compare your\nde-blurring results with unsharp masking and na¨ıve inverse ﬁltering. More sophisticated al-\ngorithms for blur removal are discussed in Sections 3.7 and 10.3.\nDiscrete cosine transform\nThe discrete cosine transform (DCT) is a variant of the Fourier transform particularly well-\nsuited to compressing images in a block-wise fashion. The one-dimensional DCT is com-\nputed by taking the dot product of each N-wide block of pixels with a set of cosines of\n3.4 Fourier transforms\n143\n-1.00\n-0.75\n-0.50\n-0.25\n0.00\n0.25\n0.50\n0.75\n1.00\n0.00\n0.25\n0.50\n0.75\n1.00\nFigure 3.26 Discrete cosine transform (DCT) basis functions: The ﬁrst DC (i.e., constant)\nbasis is the horizontal blue line, the second is the brown half-cycle waveform, etc. These\nbases are widely used in image and video compression standards such as JPEG.\ndifferent frequencies,\nF(k) =\nN−1\nX\ni=0\ncos\n\u0012 π\nN (i + 1\n2)k\n\u0013\nf(i),\n(3.76)\nwhere k is the coefﬁcient (frequency) index, and the 1/2-pixel offset is used to make the\nbasis coefﬁcients symmetric (Wallace 1991). Some of the discrete cosine basis functions are\nshown in Figure 3.26. As you can see, the ﬁrst basis function (the straight blue line) encodes\nthe average DC value in the block of pixels, while the second encodes a slightly curvy version\nof the slope.\nIn turns out that the DCT is a good approximation to the optimal Karhunen–Lo`eve decom-\nposition of natural image statistics over small patches, which can be obtained by performing\na principal component analysis (PCA) of images, as described in Section 14.2.1. The KL-\ntransform de-correlates the signal optimally (assuming the signal is described by its spectrum)\nand thus, theoretically, leads to optimal compression.\nThe two-dimensional version of the DCT is deﬁned similarly,\nF(k, l) =\nN−1\nX\ni=0\nN−1\nX\nj=0\ncos\n\u0012 π\nN (i + 1\n2)k\n\u0013\ncos\n\u0012 π\nN (j + 1\n2)l\n\u0013\nf(i, j).\n(3.77)\nLike the 2D Fast Fourier Transform, the 2D DCT can be implemented separably, i.e., ﬁrst\ncomputing the DCT of each line in the block and then computing the DCT of each resulting\ncolumn. Like the FFT, each of the DCTs can also be computed in O(N log N) time.\nAs we mentioned in Section 2.3.3, the DCT is widely used in today’s image and video\ncompression algorithms, although it is slowly being supplanted by wavelet algorithms (Si-\nmoncelli and Adelson 1990b), as discussed in Section 3.5.4, and overlapped variants of the\nDCT (Malvar 1990, 1998, 2000), which are used in the new JPEG XR standard.12 These\n12 http://www.itu.int/rec/T-REC-T.832-200903-I/en.",
  "image_path": "page_164.jpg",
  "pages": [
    163,
    164,
    165
  ]
}