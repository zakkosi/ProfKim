{
  "doc_id": "pages_063_065",
  "text": "2.1 Geometric primitives and transformations\n41\nv\nv┴\nn^\nv×\nv║\nv××\nu┴\nu\nθ\nFigure 2.5 Rotation around an axis ˆn by an angle θ.\n2.1.4 3D rotations\nThe biggest difference between 2D and 3D coordinate transformations is that the parameter-\nization of the 3D rotation matrix R is not as straightforward but several possibilities exist.\nEuler angles\nA rotation matrix can be formed as the product of three rotations around three cardinal axes,\ne.g., x, y, and z, or x, y, and x. This is generally a bad idea, as the result depends on the\norder in which the transforms are applied. What is worse, it is not always possible to move\nsmoothly in the parameter space, i.e., sometimes one or more of the Euler angles change\ndramatically in response to a small change in rotation.1 For these reasons, we do not even\ngive the formula for Euler angles in this book—interested readers can look in other textbooks\nor technical reports (Faugeras 1993; Diebel 2006). Note that, in some applications, if the\nrotations are known to be a set of uni-axial transforms, they can always be represented using\nan explicit set of rigid transformations.\nAxis/angle (exponential twist)\nA rotation can be represented by a rotation axis ˆn and an angle θ, or equivalently by a 3D\nvector ω = θˆn. Figure 2.5 shows how we can compute the equivalent rotation. First, we\nproject the vector v onto the axis ˆn to obtain\nv∥= ˆn(ˆn · v) = (ˆnˆnT )v,\n(2.29)\nwhich is the component of v that is not affected by the rotation. Next, we compute the\nperpendicular residual of v from ˆn,\nv⊥= v −v∥= (I −ˆnˆnT )v.\n(2.30)\n1 In robotics, this is sometimes referred to as gimbal lock.\n42\nComputer Vision: Algorithms and Applications (September 3, 2010 draft)\nWe can rotate this vector by 90◦using the cross product,\nv× = ˆn × v = [ˆn]×v,\n(2.31)\nwhere [ˆn]× is the matrix form of the cross product operator with the vector ˆn = (ˆnx, ˆny, ˆnz),\n[ˆn]× =\n\n\n0\n−ˆnz\nˆny\nˆnz\n0\n−ˆnx\n−ˆny\nˆnx\n0\n\n.\n(2.32)\nNote that rotating this vector by another 90◦is equivalent to taking the cross product again,\nv×× = ˆn × v× = [ˆn]2\n×v = −v⊥,\nand hence\nv∥= v −v⊥= v + v×× = (I + [ˆn]2\n×)v.\nWe can now compute the in-plane component of the rotated vector u as\nu⊥= cos θv⊥+ sin θv× = (sin θ[ˆn]× −cos θ[ˆn]2\n×)v.\nPutting all these terms together, we obtain the ﬁnal rotated vector as\nu = u⊥+ v∥= (I + sin θ[ˆn]× + (1 −cos θ)[ˆn]2\n×)v.\n(2.33)\nWe can therefore write the rotation matrix corresponding to a rotation by θ around an axis ˆn\nas\nR(ˆn, θ) = I + sin θ[ˆn]× + (1 −cos θ)[ˆn]2\n×,\n(2.34)\nwhich is known as Rodriguez’s formula (Ayache 1989).\nThe product of the axis ˆn and angle θ, ω = θˆn = (ωx, ωy, ωz), is a minimal represen-\ntation for a 3D rotation. Rotations through common angles such as multiples of 90◦can be\nrepresented exactly (and converted to exact matrices) if θ is stored in degrees. Unfortunately,\nthis representation is not unique, since we can always add a multiple of 360◦(2π radians) to\nθ and get the same rotation matrix. As well, (ˆn, θ) and (−ˆn, −θ) represent the same rotation.\nHowever, for small rotations (e.g., corrections to rotations), this is an excellent choice.\nIn particular, for small (inﬁnitesimal or instantaneous) rotations and θ expressed in radians,\nRodriguez’s formula simpliﬁes to\nR(ω) ≈I + sin θ[ˆn]× ≈I + [θˆn]× =\n\n\n1\n−ωz\nωy\nωz\n1\n−ωx\n−ωy\nωx\n1\n\n,\n(2.35)\n2.1 Geometric primitives and transformations\n43\nwhich gives a nice linearized relationship between the rotation parameters ω and R. We can\nalso write R(ω)v ≈v + ω × v, which is handy when we want to compute the derivative of\nRv with respect to ω,\n∂Rv\n∂ωT = −[v]× =\n\n\n0\nz\n−y\n−z\n0\nx\ny\n−x\n0\n\n.\n(2.36)\nAnother way to derive a rotation through a ﬁnite angle is called the exponential twist\n(Murray, Li, and Sastry 1994). A rotation by an angle θ is equivalent to k rotations through\nθ/k. In the limit as k →∞, we obtain\nR(ˆn, θ) = lim\nk→∞(I + 1\nk [θˆn]×)k = exp [ω]×.\n(2.37)\nIf we expand the matrix exponential as a Taylor series (using the identity [ˆn]k+2\n×\n= −[ˆn]k\n×,\nk > 0, and again assuming θ is in radians),\nexp [ω]×\n=\nI + θ[ˆn]× + θ2\n2 [ˆn]2\n× + θ3\n3! [ˆn]3\n× + · · ·\n=\nI + (θ −θ3\n3! + · · ·)[ˆn]× + (θ2\n2 −θ3\n4! + · · ·)[ˆn]2\n×\n=\nI + sin θ[ˆn]× + (1 −cos θ)[ˆn]2\n×,\n(2.38)\nwhich yields the familiar Rodriguez’s formula.\nUnit quaternions\nThe unit quaternion representation is closely related to the angle/axis representation. A unit\nquaternion is a unit length 4-vector whose components can be written as q = (qx, qy, qz, qw)\nor q = (x, y, z, w) for short. Unit quaternions live on the unit sphere ∥q∥= 1 and antipodal\n(opposite sign) quaternions, q and −q, represent the same rotation (Figure 2.6). Other than\nthis ambiguity (dual covering), the unit quaternion representation of a rotation is unique.\nFurthermore, the representation is continuous, i.e., as rotation matrices vary continuously,\none can ﬁnd a continuous quaternion representation, although the path on the quaternion\nsphere may wrap all the way around before returning to the “origin” qo = (0, 0, 0, 1). For\nthese and other reasons given below, quaternions are a very popular representation for pose\nand for pose interpolation in computer graphics (Shoemake 1985).\nQuaternions can be derived from the axis/angle representation through the formula\nq = (v, w) = (sin θ\n2 ˆn, cos θ\n2),\n(2.39)",
  "image_path": "page_064.jpg",
  "pages": [
    63,
    64,
    65
  ]
}